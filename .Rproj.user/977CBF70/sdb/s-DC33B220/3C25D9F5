{
    "contents" : "library(shiny)\nlibrary(shinyIncubator)\nlibrary(hwriter)\n\nsource(\"helper.R\")\n\n# Define server logic required to draw a heatmap\nshinyServer(function(input, output, session) {\n    \n    ## A reactive expression computing what to cluster and display\n    data <- reactive({\n        if (is.null(input$samples) || input$pval==0) {\n            return(NULL)\n        } else {\n            samples <- input$samples ## Just to make the code smaller to read\n            ## Keep any gene that passes the FC and pval filter in one experiment\n            filter <- rowSums(sapply(saved.data[samples], function(d){\n                ## here, I am filtering on the pvalue and fold change the user chooses\n                ## Creating two filters depending on reactive values from the UI\n                fc.filter <- abs(d$table$logFC) >= log2(input$FC)\n                pv.filter <- d$table$PV <  input$pval\n                return(fc.filter & pv.filter)\n            })) > 0\n            ## get the fold change as a matrix\n            FC.mat <- do.call(cbind,lapply(saved.data[samples],function(d){\n                res <- data.frame(d$table$logFC)\n                rownames(res) <- rownames(d$table)\n                return(res)\n            }))\n            colnames(FC.mat) <- names(saved.data[samples])\n            ## Filter the data\n            return(FC.mat[filter,,drop=FALSE])\n        }\n    })\n    \n    ## Generate the cluster, a second reactive expression\n    ## here, I am making it reactive so that I could provide the user\n    ## with different clustering algorithm choices (Pearson, Spearman, Euclidean, etc...)\n    ## Using a observer on the data to make sure I have something to cluster.\n    ## Could perhaps merge with lower evaluation\n    cluster <- reactive({\n        if(length(data()) == 0){\n            return(NULL)\n        } else {\n            ## filter the NA value first\n            forHeatmap <- data()[!apply(is.na( data() ),1,any),]\n            ## Returning the clustered data\n            hc <- try(as.dendrogram(hclust(dist( forHeatmap ))),silent=TRUE)\n            if(class(cluster) == 'try-error'){\n                return(NULL)\n            } else {\n                return(hc)\n            }\n        }\n    })\n    \n    ## Computing a cluster colored based on selected height\n    color.cluster <- reactive ({\n        if (is.null(cluster())){\n            return(NULL)\n        } else {\n            if (length(input$height) != 0){\n                hc <- colBranches(cluster(),input$height,hc.cols)\n            }\n        }\n    })\n\n    ## Rendering a slider to select the height used to break the cluster\n    output$heightSelector <- renderUI({\n        if (is.null(cluster())){\n            return(NULL)\n        } else {\n            h <- attributes(cluster())$height\n            list(hr(),\n                 h5(\"Creating clusters of genes\"),\n                 sliderInput(\"height\",\n                             \"Break in clusters at height of:\",\n                             min = round(h*0.2,2),\n                             max = h,\n                             value = h,\n                             format = '#.00'\n                             )\n                 )\n        }\n    })\n    \n    ## Create a set of reactive values to store tables of genes displayed in the heatmap\n    values <- reactiveValues()\n    ## Create a reactive context to assign the reactive values\n    observe({\n        if(is.null(data())){\n            values <- NULL\n        } else {\n            for (s in input$samples) {\n                ## The reactive values data() should trigger re-evalution of this bit on modification\n                geneSymbol <- gene2name$external_gene_id[match(rownames(data()),gene2name$ensembl_gene_id)]\n                linkOut <- 'http://flybase.org/reports/'\n                links <- hwrite(geneSymbol, \n                                link = paste0(linkOut,rownames(data())),\n                                target = s,\n                                table = FALSE)\n                \n                d <- data.frame('id'= links,\n                                saved.data[[s]]$table[rownames(data()),c('logFC','PValue')])\n                \n                d$adj.p <- p.adjust(d$PV,'BH')\n                colnames(d) <- c('Gene','log2(FC)','p-value','adj. p-value')\n                values[[s]] <- d\n            }\n\n        }\n    })\n    \n    ## Rendering our heatmap\n    ## The ui main panel is render at the same time\n    ## Have some logic to deal with user not clicking any samples\n    observe({\n        if(length(input$samples) == 0 || is.null(values) || is.null(color.cluster())){\n            ## Wipeout the ploting area\n            output$main <- renderUI({ return(NULL) })\n            ## Wipeout the tabsets\n            output$plotUI <- renderUI({ tabsetPanel(\"tabPanel\") })\n            ## Remove the message of number of genes selected\n            output$message <- renderUI({ return(NULL) })\n        } else {\n            ## Print a message with the number of selected genes\n            output$message <- renderUI({\n                list(hr(),\n                     h5(paste(nrow(data()),\"genes are selected\"))\n                     )\n            })\n            ## Create a UI with tab panels, one for the plot and one for each slected samples\n            output$plotUI <- renderUI({\n                ## Dynamically render tabset based on the user selected samples\n                do.call(tabsetPanel,\n                        c(call(\"tabPanel\",\"Plot\",\n                               call(\"plotOutput\",\"plot\",height='600px'),\n                               call(\"downloadButton\",'img','Save as png')\n                               ),\n                          call(\"tabPanel\",\"Clusters\",\n                               call(\"uiOutput\",\"clusters\")),\n                          lapply(input$samples,function(s){\n                              call(\"tabPanel\",s,\n                                   call('textOutput',paste0(\"text_\",s)),\n                                   call('dataTableOutput',paste0(\"table_\",s)),\n                                   call(\"downloadButton\",paste0(\"save_\",s),'Save as csv')\n                                   )\n                          })\n                          )\n                        )\n            })\n\n            ##withProgress(session, {\n              ##  setProgress(message = \"Recomputing the heatmap and cluster data\",\n                ##            detail = \"This may take a few moments...\")\n            output$plot <- renderPlot({\n                plotHeatMap(data(),\n                            color.cluster(),\n                            c(input$zlim.low,input$zlim.high),\n                            input$height\n                            )\n            })\n        }\n    })\n    \n    ## Create a reactive context to populate the sample tab panels with content\n    observe({\n        lapply(names(values), function(s){\n            ## Do some cleanup before saving\n            d <- values[[s]]\n            d$Gene <- sub(\"<a.+?>(.+)</a>\",\"\\\\1\",d$Gene)\n            d <- cbind(FBid=rownames(d),d)\n            ## Add a DataTable of gene selected in the heatmap\n            output[[paste0('table_',s)]] <- renderDataTable(values[[s]],options=list(iDisplayLength=10))\n            ## Add a download button to allow download of a csv file\n            output[[paste0('save_',s)]] <- downloadHandler(\n                filename = function() { paste0(s,\".csv\") },\n                content = function(file) { write.csv(d,file=file,row.names=FALSE) }\n                )\n            return(s)\n        })\n    })\n    \n    ## Create a reactive context to populate the cluster tab panel\n    observe({\n        if (!is.null(color.cluster()) ){\n            ## Cutting the clustering into sub-group\n            cuts <- cut(color.cluster(),h=input$height) \n            sub.dendro <- rev(cuts$lower)\n            groups <- lapply(sub.dendro,unlist)\n\n            ## Creating a new UI for each group\n            ui <- unlist(lapply(seq(groups),function(i){\n                c(call(\"h3\",paste(\"Cluster\",i)),\n                  call(\"plotOutput\",paste0(\"subDendro_\",i),height=\"100px\",width=\"100px\"),\n                  call(\"dataTableOutput\",paste0(\"cluster_\",i)),\n                  call(\"downloadButton\",paste0(\"saveCluster_\",i),'Save as csv'),\n                  call(\"hr\")\n                  )\n                \n            }))\n            output$clusters <- renderUI({ lapply(ui,eval) })\n\n            ## Rendering the sub-dendro plot and a table of genes\n            lapply(seq(groups),function(i){\n                output[[paste0('subDendro_',i)]] <- renderPlot({\n                    par(mar=rep(0,4))\n                    plot(sub.dendro[[i]],\n                         axes=FALSE,\n                         yaxt='s',\n                         yaxs='i',\n                         xaxt='n',\n                         xaxs='i',\n                         horiz=TRUE,\n                         leaflab='none')\n                })\n\n                ## Rendering the tables of gene for each cluster, linking out to flybase\n                geneIds <- rownames(data())[groups[[i]]]\n                geneSymbol <- gene2name$external_gene_id[match(geneIds,gene2name$ensembl_gene_id)]\n                linkOut <- 'http://flybase.org/reports/'\n                links <- hwrite(geneSymbol, \n                                link = paste0(linkOut,geneIds),\n                                target = 'subCluster',\n                                table = FALSE)\n\n                d <- as.data.frame(sapply(input$samples,function(s) saved.data[[s]]$table[geneIds,'logFC']))\n                names(d) <- paste(names(d),\"Log2(FC)\")\n                \n                output[[paste0('cluster_',i)]] <- renderDataTable(cbind(Genes=links,d),\n                                                                  options=list(iDisplayLength=10))\n                \n                ## Creating functions to save the tables link to the buttons\n                output[[paste0('saveCluster_',i)]] <- downloadHandler(\n                    filename = function() { paste0(\"cluster_\",i,\"_h\",round(input$height,1),\".csv\") },\n                    content = function(file) {\n                        write.csv(data.frame(gene.id=geneIds,symbol=geneSymbol),\n                                  file=file,row.names=FALSE)\n                    }\n                    )\n            })\n        }\n        \n    })\n    \n    ## Function to download the heatmap as png\n    output$img <- downloadHandler(\n        filename = function() { \"heatmap.png\" },\n        content = function(file) {\n            png(file)\n            plotHeatMap(data(),cluster(),c(input$zlim.low,input$zlim.high),input$height,noMarker=TRUE)\n            dev.off()\n        }\n        )\n})\n\n\n\n\n",
    "created" : 1411769469401.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "624619676",
    "id" : "3C25D9F5",
    "lastKnownWriteTime" : 1411769252,
    "path" : "~/GDrive/GitLib/heatmap-app/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}